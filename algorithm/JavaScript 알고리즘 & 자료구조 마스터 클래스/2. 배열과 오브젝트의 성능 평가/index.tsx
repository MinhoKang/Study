// 배열, 오브젝트 등등 어느 것이 더 좋은 성능을 보이는가

// 1. 객체
// 객체는 정렬되어 있을 필요가 없을 때 잘 작동하고
// 빠른 접근, 입력, 제거에 유용
// BigO의 관점에서 삽입, 삭제, 접근은 O(1)이지만 검색은 O(n)
// 검색은 키를 통해 값을 찾아야 하기 때문에 O(n)이 됨

// Object.keys, Object.values, Object.entries는 O(n)
// 모든 키를 돌면서 배열에 넣어야 하기 때문
// Object.hasOwnProperty는 O(1) (해당 키가 있는지 확인하는 것이므로)

// 2. 배열
// 배열은 정렬되어있어야 한다 -> 정렬되어있는 데이터를 위해 사용
// 입력과 제거를 할 때 성능이 달라질 수 있음
// 접근은 O(1), 삽입과 삭제는 O(n) (배열의 길이에 따라 성능이 달라짐)
// 접근이 O(1)인 이유는 배열의 인덱스를 통해 바로 접근할 수 있기 때문
// 검색은 O(n) (배열의 길이에 따라 성능이 달라짐)

// 삽입은 단순히 push일 경우에는 객체에 추가하는 것과 다를바 없음 -> O(1)
// 하지만 배열의 중간이나 처음에 추가할 경우 다른 원소의 인덱스에 영향을 줘서 O(n)이 됨
// 이는 삭제도 마찬가지

// 3. 내장된 배열 BigO 메서드
// push, pop -> O(1)
// shift, unshift -> O(n)
// concat, slice, splice -> O(n)
// sort -> O(n * log n)
// forEach, map, filter, reduce, etc. -> O(n)
// indexOf, includes, find, findIndex -> O(n)


// 객체는 정렬되어 있지 않지만 빠르고
// 배열은 정렬되어 있지만 느림